'''
Faraday Penetration Test IDE
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import pytest
from faraday.server.models import (
    CommandObject,
    PolicyViolation,
    PolicyViolationVulnerabilityAssociation,
    Reference,
    ReferenceVulnerabilityAssociation,
)


def test_standard_host_vuln_hostnames(vulnerability_factory,
                                      host_with_hostnames,
                                      session):
    """Tests the relationship between a vulnerability and its associated hostnames.
    
    Args:
        vulnerability_factory (VulnerabilityFactory): A factory object for creating vulnerabilities.
        host_with_hostnames (Host): A host object with associated hostnames.
        session (Session): The database session for committing changes.
    
    Returns:
        None
    
    Raises:
        AssertionError: If the set of hostnames associated with the vulnerability does not match the set of hostnames associated with the host.
    """
    vuln = vulnerability_factory.create(host=host_with_hostnames,
                                        service=None, workspace=host_with_hostnames.workspace)
    session.commit()

    assert set(vuln.hostnames) == set(host_with_hostnames.hostnames)


def test_standard_vuln_service_hostnames(vulnerability_factory,
                                         service_factory,
                                         host_with_hostnames,
                                         session):
    """Test standard vulnerability service hostnames.
    
    Args:
        vulnerability_factory (FactoryClass): Factory for creating vulnerability objects.
        service_factory (FactoryClass): Factory for creating service objects.
        host_with_hostnames (Host): Host object with associated hostnames.
        session (Session): Database session object for committing changes.
    
    Returns:
        None: This method doesn't return anything. It uses assertions to verify behavior.
    
    Raises:
        AssertionError: If the set of hostnames associated with the vulnerability doesn't match the set of hostnames associated with the host.
    """
    service = service_factory.create(host=host_with_hostnames, workspace=host_with_hostnames.workspace)
    vuln = vulnerability_factory.create(service=service, host=None, workspace=host_with_hostnames.workspace)
    session.commit()
    assert set(vuln.hostnames) == set(host_with_hostnames.hostnames)


def test_web_vuln_hostnames(vulnerability_web_factory,
                            service_factory,
                            host_with_hostnames,
                            session):
    """Tests if web vulnerability hostnames match the host's hostnames.
    
    Args:
        vulnerability_web_factory (Factory): Factory for creating web vulnerabilities.
        service_factory (Factory): Factory for creating services.
        host_with_hostnames (Host): Host object with associated hostnames.
        session (Session): Database session for committing changes.
    
    Returns:
        None: This method doesn't return anything explicitly.
    
    Raises:
        AssertionError: If the vulnerability's hostnames don't match the host's hostnames.
    """
    service = service_factory.create(host=host_with_hostnames, workspace=host_with_hostnames.workspace)
    vuln = vulnerability_web_factory.create(service=service, workspace=host_with_hostnames.workspace)
    session.commit()
    assert set(vuln.hostnames) == set(host_with_hostnames.hostnames)


def test_code_vuln(vulnerability_code, session):
    session.commit()
    # Source code vulnerabilities have no hostnames
    assert vulnerability_code.hostnames == []


class TestReferences:

    field_name = 'references'
    instances_field_name = 'reference_instances'
    model = Reference
    intermediate_model = ReferenceVulnerabilityAssociation
    intermediate_field = 'reference'

    @pytest.fixture(autouse=True)
    def load_data(self, vulnerability_factory, session):
        """Load and create vulnerability objects for testing purposes.
        
        Args:
            self: The instance of the class containing this method.
            vulnerability_factory (VulnerabilityFactory): A factory object used to create vulnerability instances.
            session (Session): The database session used for committing changes.
        
        Returns:
            None
        
        Raises:
            AssertionError: If the workspace IDs of self.vuln and self.vuln_different_ws are the same.
        
        """
        self.vuln = vulnerability_factory.create()
        self.vuln2 = vulnerability_factory.create(
            workspace=self.vuln.workspace)
        self.vuln_different_ws = vulnerability_factory.create()
        self.vulns = [self.vuln, self.vuln2, self.vuln_different_ws]
        session.commit()
        assert self.vuln.workspace_id != self.vuln_different_ws.workspace_id

    @pytest.fixture
    def child(self, session):
        """Adds a child CVE vulnerability to the database session.
        
        Args:
            session (sqlalchemy.orm.Session): The database session to use for adding and committing the child vulnerability.
        
        Returns:
            CVE: The newly created child vulnerability object.
        """
        child = self.model('CVE-2017-1234', self.vuln.workspace_id)
        session.add(child)
        session.commit()
        return child

    def childs(self, vuln=None, instance=False):
        """Returns child vulnerabilities or instances associated with a given vulnerability.
        
        Args:
            self: The instance of the class containing this method.
            vuln (Vulnerability, optional): The vulnerability object to get children from. Defaults to self.vuln.
            instance (bool, optional): If True, returns instances; if False, returns vulnerabilities. Defaults to False.
        
        Returns:
            list: A list of child vulnerabilities or instances associated with the given vulnerability.
        """
        vuln = vuln or self.vuln
        field = self.instances_field_name if instance else self.field_name
        return getattr(vuln, field)

    def test_empty_references(self):
        for vuln in self.vulns:
            assert isinstance(self.childs(vuln, True), set)
            assert len(vuln.references) == 0

    def test_add_references(self, session):
        """Test the addition of references to a vulnerability.
        
        Args:
            self: The test class instance.
            session (sqlalchemy.orm.Session): The database session for performing operations.
        
        Returns:
            None
        
        Raises:
            AssertionError: If any of the test assertions fail.
        """
        self.childs().add('CVE-2017-1234')
        session.add(self.vuln)
        assert session.new
        session.commit()
        assert self.model.query.count() == 1
        ref = self.model.query.first()
        assert ref.name == 'CVE-2017-1234'
        assert ref.workspace_id == self.vuln.workspace_id

        # Re-adding the reference shouldn't do nothing
        self.childs().add('CVE-2017-1234')
        assert self.model.query.count() == 1

    def test_add_existing_child(self, session, child):
        """Test adding an existing child to vulnerabilities.
        
        Args:
            self: The instance of the test class.
            session (Session): The database session for committing changes.
            child (Child): The existing child object to be added.
        
        Returns:
            None
        
        Raises:
            AssertionError: If the assertions for model count or child relationships fail.
        """
        for vuln in [self.vuln, self.vuln2]:
            self.childs(vuln).add('CVE-2017-1234')
            session.commit()
            assert self.model.query.count() == 1
            assert len(self.childs(vuln)) == 1
            assert self.childs(vuln, True).pop().id == child.id

    @pytest.mark.parametrize('orphan_vuln', [True, False],
                             ids=['with_orphan_child',
                                  'with_used_child'])
    def test_add_existing_from_other_workspace(self, session, child,
                                               orphan_vuln):
        """Tests adding an existing child from a different workspace.
        
        This method tests the functionality of adding a child vulnerability that already exists in a different workspace. It verifies that the child is correctly added to the current vulnerability and that a new instance of the child is created in the new workspace.
        
        Args:
            self: The test class instance.
            session (Session): The database session for performing operations.
            child (Vulnerability): The child vulnerability to be added.
            orphan_vuln (bool): Flag indicating whether the vulnerability is an orphan.
        
        Returns:
            None
        
        Raises:
            AssertionError: If the test conditions are not met.
        """
        if not orphan_vuln:
            self.childs().add(child.name)
            session.commit()
        self.childs(self.vuln_different_ws).add(child.name)
        session.add(self.vuln_different_ws)
        session.commit()
        assert self.model.query.count() == 2
        assert len(self.childs(self.vuln_different_ws)) == 1
        new_child = self.childs(self.vuln_different_ws, True).pop()
        assert (new_child.workspace_id
                == self.vuln_different_ws.workspace_id)
        assert new_child.id != child.id

    def test_remove_reference(self, session, child):
        """Test method to remove a reference between a vulnerability and a child object.
        
        Args:
            self: The instance of the class containing this method.
            session (sqlalchemy.orm.session.Session): The database session for performing operations.
            child (object): The child object to be removed from the vulnerability reference.
        
        Returns:
            None
        
        Raises:
            AssertionError: If the reference is not successfully removed from the database.
        """
        session.add(self.vuln)
        self.childs().add(child.name)
        session.commit()
        self.childs().remove(child.name)
        session.commit()
        filters = {
            'vulnerability': self.vuln,
            self.intermediate_field: child
        }
        assert self.intermediate_model.query.filter_by(**filters).count() == 0

    @pytest.mark.skip('not implemented yet')
    def test_removes_orphan(self):
        pass

    @pytest.mark.parametrize('previous_childs,new_childs', [
        (set(), set()),
        (set(), {'CVE-2017-1234'}),
        ({'CVE-2017-1234'}, set()),
        ({'CVE-2017-1234'}, {'CVE-2017-1234'}),
        ({'CVE-2017-1234'}, {'CVE-2017-4321'}),
        ({'CVE-2017-1234'}, {'CVE-2017-1234', 'CVE-2017-4321'}),
    ], ids=[
        '{} -> {}',
        '{} -> {a}',
        '{a} -> {}',
        '{a} -> {a}',
        '{a} -> {b}',
        '{a} -> {a, b}',
    ])
    def test_direct_assignation(self, session, previous_childs, new_childs):
        """Tests direct assignment of child references to a vulnerability.
        
        This method tests the behavior of directly assigning new child references to a vulnerability
        object, ensuring that the assignment is correctly persisted and retrieved from the database.
        
        Args:
            self: The test class instance.
            session (Session): The database session object used for database operations.
            previous_childs (list): A list of child references to be initially added to the vulnerability.
            new_childs (list): A list of new child references to be assigned to the vulnerability.
        
        Returns:
            None
        
        Raises:
            AssertionError: If the final set of child references doesn't match the new_childs list.
        """
        for ref in previous_childs:
            self.childs().add(ref)
        session.add(self.vuln)
        session.commit()
        setattr(self.vuln, self.field_name, new_childs)
        session.commit()
        session.refresh(self.vuln)
        assert self.childs() == new_childs

    def test_create_workspace_and_vuln_with_childs(
            self, session, vulnerability_factory, child):
        # This should not raise an error since the workspace will be propagated
        # to the childs as created vuln has a workspace and is persisted
        """Test the creation of a workspace and vulnerability with child objects.
        
        Args:
            self: The test class instance.
            session: The database session object.
            vulnerability_factory: A factory object for creating vulnerabilities.
            child: A child object related to the vulnerability.
        
        Returns:
            None
        
        Raises:
            None
        
        This method tests the creation of a workspace and vulnerability with associated child objects.
        It verifies that no error is raised when creating a vulnerability with a workspace,
        as the workspace should be propagated to the child objects. The method also sets
        a custom field on the vulnerability using the 'field_name' attribute.
        """
        vuln = vulnerability_factory.create()
        setattr(vuln, self.field_name, {'CVE-2017-1234'})

    def test_create_vuln_with_childs(self, session, vulnerability_factory):
        """Test the creation of a vulnerability with child entities.
        
        Args:
            self: The test class instance.
            session (Session): The database session object for performing database operations.
            vulnerability_factory (Factory): A factory object for creating vulnerability instances.
        
        Returns:
            None: This method doesn't return anything explicitly, but performs assertions.
        
        Raises:
            AssertionError: If any of the assertions fail during the test.
        """
        vuln = vulnerability_factory.build()
        session.add(vuln.workspace)
        session.commit()
        assert vuln.workspace.id
        setattr(vuln, self.field_name, {'CVE-2017-1234'})
        session.add(vuln)
        session.commit()
        assert len(self.childs(vuln)) == 1
        assert self.model.query.count() == 1


class TestPolicyViolations(TestReferences):
    field_name = 'policy_violations'
    instances_field_name = 'policy_violation_instances'
    model = PolicyViolation
    intermediate_model = PolicyViolationVulnerabilityAssociation
    intermediate_field = 'policy_violation'


class TestCommandProperties:
    def test_no_creator_command(self, vulnerability, session):
        session.commit()
        assert vulnerability.creator_command_id is None
        assert vulnerability.creator_command_tool is None

    def test_creator_command(self, workspace, vulnerability,
                             empty_command_factory, session):
        """Tests the creation of a vulnerability with associated commands.
        
        This method creates a vulnerability and a set of commands, linking them together
        and verifying the correct associations are made. It tests the creation of
        CommandObjects and ensures the creator command is properly set for the vulnerability.
        
        Args:
            self: The test class instance.
            workspace (Workspace): The workspace where the vulnerability and commands will be created.
            vulnerability (Vulnerability): The vulnerability object to be tested.
            empty_command_factory (Factory): A factory for creating empty command objects.
            session (Session): The database session for performing operations.
        
        Returns:
            None
        
        Raises:
            AssertionError: If any of the assertions fail during the test.
        """
        command = empty_command_factory.create(workspace=workspace)
        session.add(vulnerability)
        session.flush()
        assert vulnerability.id is not None
        assert command.id is not None
        assert vulnerability.workspace is workspace
        assert command.workspace is workspace

        CommandObject.create(
            vulnerability,
            command
        )
        for _ in range(5):
            new_command = empty_command_factory.create(workspace=workspace)
            session.flush()
            session.add(CommandObject(vulnerability,
                                      command=new_command,
                                      workspace=workspace,
                                      created_persistent=False))
        session.commit()
        assert vulnerability.creator_command_id == command.id
        assert vulnerability.creator_command_tool == command.tool

    def test_different_object_type(self, vulnerability, workspace,
                                   empty_command_factory, session):
        """Tests the behavior of creating CommandObjects with different object types.
        
        This method tests the creation of CommandObjects associated with a vulnerability
        and multiple commands. It specifically checks the handling of invalid object types
        and the correct assignment of the creator command to the vulnerability.
        
        Args:
            self: The test class instance.
            vulnerability (Vulnerability): The vulnerability object to be associated with commands.
            workspace (Workspace): The workspace in which the commands and objects are created.
            empty_command_factory (CommandFactory): A factory for creating empty command objects.
            session (Session): The database session for performing database operations.
        
        Returns:
            None
        
        Raises:
            AssertionError: If the vulnerability's creator_command_id or creator_command_tool
                            does not match the expected values.
        """
        command = empty_command_factory.create(workspace=workspace)
        session.add(vulnerability)
        session.flush()
        invalid_co = CommandObject.create(vulnerability, command)
        invalid_co.object_type = 'host'
        session.add(invalid_co)
        session.commit()

        command = empty_command_factory.create(workspace=workspace)
        session.flush()

        CommandObject.create(
            vulnerability,
            command
        )
        for _ in range(5):
            new_command = empty_command_factory.create(workspace=workspace)
            session.flush()
            session.add(CommandObject(vulnerability,
                                      command=new_command,
                                      workspace=workspace,
                                      created_persistent=False))
        session.commit()
        assert vulnerability.creator_command_id == command.id
        assert vulnerability.creator_command_tool == command.tool
